
---
注意我这个代码在使用前都添加了下面几个库函数。
```python
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
```
并且采用`python`语法进行编程处理，用`python`的主要原因还是老师。
![](https://i-blog.csdnimg.cn/img_convert/da96e65210c0ff5e38b38e87ba5c6ad1.png)

---
### 1. **`cv.imread()`**
1. 读取图片
2. 主要有一个参数便是输入图像的相对位置。
3. 这个函数的输出是一个矩阵
4. 例如：`cv.imread('0.picture/cat.jpg')`
5. 下面进行该函数的进阶读取操作
	1. `cv.imread('0.picture/cat.jpg',cv.IMREAD_GRAYSCALE)`,其最后一个参数可以填写读取的方式。
	2. `IMREAD_UNCHANGED               #基本没用过我也不知道`
	3. `IMREAD_GRAYSCALE                 #读取一张灰度图片`
	4. `IMREAD_COLOR                           # 默认的读取方式 读取`
### 2. **`cv.imshow()`**
1. 显示图片
2. 第一个参数指的是展示图片窗口名
3. 第二个参数指的是展示的图片是那一张
4. 例如：`cv.imshow('picture_1',img)`
### 3. **`图像名称.shape`**
1. 计算图片的大小（长宽通道）
2. 没有参数，主要的是前面的哪一个图像的名称不可以输入错误。
3. 这个函数的输出是一个矩阵，矩阵有三个数据
	1. 第一个数据是高度
	2. 第二个数据是宽度
	3. 第三个数据是颜色通道(RGB)
4. 例如:`img.shape`
### 4. **`cv.waitKey()`**
1. 等待一段时间
2. 主要有一个参数填入括号中。
	1. 如果填入的数据是`0`那么表示任意键停止
	2. 如果填入的是其他的数据那么表示的是等待X毫秒停止
3. 例如:`cv.waitKey(0) #表示任意键停止          cv.waitKey(1000) #表示等待1000毫秒后停止`
### 5. **`cv.destroyAllWindows()`**
1. 关闭所有的windows窗口
2. 这个函数不存在参数的设置，这个函数的作用是关闭所有的Windows窗口的哈。
3. 例如:`cv.destroyAllWindows()`
### 6. **`cv.imwrite()`**
1. 这个函数是用来存储图像。
2. 第一个参数是，存储的图像所需要保存的名称
3. 第二个参数是，需要存储的图像
4. 例如:`cv.imwrite('hellow',img)`
### 7. **`cv.VideoCapture`**
1. 这个函数用来读取视频的。
2. 只有一个参数，视频的位置
	1. 如果输入数字，那么就是调用本地的摄像头硬件。
	2. 如果输入相对位置，那么就是用来读取本地的视频的。
3. 例如`vc=cv.VideoCapture(0)`
### 8. **`视频名称.read()`**
1. 这个函数应当和上面的函数7相互使用一起用
2. 他这个函数的输入就是读取的视频，输出有两个参数
	1. 第一个输出的参数是，bool值看看是否读取到当前帧
	2. 第二个输出的参数是，frame也就是当前帧的图像
3. 例如:`open,frame = vc.read()`
### 9. **`cv.cvtColor()`**
1. 这个函数非常重要，是空间转换的一个函数，用来更改颜色空间的
2. 主要有两个参数的输入，一个参数的输出
	1. 第一个输入参数，需要转换颜色的图片。
	2. 第二个输入的参数，转换的方式也可以说是关键字，大部分关键字现在给出。
		1. `cv.COLOR_BGR2BGRA`     
		2. `cv.COLOR_RGB2BGRA`                   
		3. `cv.COLOR_BGRA2RGBA`        
		4. `cv.COLOR_BGR2BGRA`         
		5. `cv.COLOR_BGRA2BGR`      
		6. `cv.COLOR_RGB2GRAY`  
		7. `cv.COLOR_RGB2HSV`
		8. `cv.COLOR_RGB2YUV`
		9. `cv.COLOR_RGB2LAB`
3. 例如:`Gray = cv.cvtColor(frame,cv.COLOR_RGB2GRAY)`
### 10. **`视频名称.release()`**
1. 这个函数就是用来释放缓存的
2. 它主要有一个参数也就是输入的视频信号vc
3. 例如:`vc.release()`
### 11. **`图像名称.copy()`**
1. 这个函数的主要作用是复制当前的图片。
2. 它主要有一个输入一个输出。
3. 输入的是被复制的图像，输入的是复制后的图像
4. 例如:`img_copy = img.copy()`
### 12. **`cv.copyMakeBorder()`**
1. 这个函数的作用是进行图像的边缘填充的操作
2. 它主要有六个输入参数。
	1. 需要处理的图片名
	2. 顶部填充的像素大小
	3. 底部填充的像素大小
	4. 左边填充的像素大小
	5. 右边填充的像素大小
	6. 填充的方法（类型）
		1. `cv.BORDER_REFLECT`
		2. `cv.BORDER_REPLICATE`
		3. `cv.BORDER_REFLECT101`
		4. `cv.BORDER_WRAP`
		5. `cv.BORDER_CONSTANT,value=2`
		6. 从上倒下依次为**复制法、反射法1、反射法2、外包装法、常量法**
3. 例如:`img_reflect= cv.copyMakeBorder(img,top_size,bottom_size,left_size,right_size,borderType=cv.BORDER_REFLECT)`
### 13. **`cv.resize()`**
1. 这个函数用来更改图像的长宽大小
2. 这个函数的输入有两个数据
	1. 需要变换大小的图像。
	2. 更改后的大小
3. **这个函数非常的坑人**，注意哈，我们采用`shape`函数之后得到的是$height \times weigth$，但是这个函数的输入恰好**相反**，它是$weigth \times height$
4. 例如：我现在需要将一个图像变为大小为$\begin{bmatrix} 500，& 900， &3 \end{bmatrix}$的大小则需要的使用的函数为`img =cv.resize(img,(900,500))·是不是特别的反人类呀。
### 14. **`cv.addWeighted()`**
1. 这个函数的作用是用来将两个**大小相同**的图像进行合成的。
2. 它主要有五个输入的参数。
	1. 图像一
	2. 图像一的不透明度
	3. 图像二
	4. 图像二的不透明度
	5. 亮度
3. 例如：`res = cv.addWeighted(img1,0.5,img2,0.5,0)`,这个就表示了img1以及img2这两个图像的合成，其合成公式为$R=img1 \times 0.5+picture2 \times 0.5+0$
### 15. **`cv.threshold()`**
1. 这个函数的作用是用来处理图像的阈值，进行二值化处理
2. 主要有四个输入的参数，并且返回两个数据
	1. 第一个参数：需要进行二值化处理的图片
	2. 第二个参数：阈值大小
	3. 第三个参数：最大的数据
	4. 采用的方法
		1. `cv.THRESH_BINARY`，二值法 若大于阈值则直接取最大值，若小于阈值则取0。
		2. `cv.THRESH_BINARY_INV`，二值法 的反转
		3. `cv.THRESH_TRUNC`，截断法 大于128的直接等于128，小于128的直接不进行变化。
		4. `cv.THRESH_TOZERO`，大于的部分直接不变，小于等于128的直接成为0
		5. `THRESH_TOZERO_INV`，和上面相反
3. 例如：`ret,dst1 = cv.threshold(Img_Cat_Gray,150,255,cv.THRESH_BINARY)`
	1. 注意他的输出第一个数据指的是阈值大小
	2. **第二个数据才是输出的图像矩阵**
### 15. **`cv.blur()`**
1. 均值滤波，他主要就是用来进行图片的降噪处理的具体的方法如图下
	1. 首先对于各个图像而言都是由矩阵组成的因此每个像素点都代表了一个数据，现在用灰度图片进行举例，对于灰度图片而言，他的各个像素点的数据均是从$0-255$，0表示黑色，255表示白色，那么对于一个图像矩阵可以简单的表示如下$$
	\left( \begin{matrix}{}
		a_{11}&		a_{12}&		·&		·&		a_{1n}\\
		a_{21}&		a_{22}&		·&		·&		a_{2n}\\
		·&		·&		·&		·&		·\\
		·&		·&		·&		·&		·\\
		a_{n1}&		a_{n2}&		·&		·&		a_{nn}\\
	\end{matrix} \right) $$
	2. 现在我用一个$3\times 3$的单位矩阵不断的同其中的各个大小相同的矩阵进行相乘并且除以元素的数量则可以得到下面的公式$$
\left( \begin{matrix}
	1&		1&		1\\
	1&		1&		1\\
	1&		1&		1\\
\end{matrix} \right) \times \left( \begin{matrix}
	a_{11}&		a_{12}&		a_{13}\\
	a_{21}&		a_{22}&		a_{23}\\
	a_{31}&		a_{32}&		a_{33}\\
\end{matrix} \right) \times \left( \begin{matrix}
	1&		1&		1\\
	1&		1&		1\\
	1&		1&		1\\
\end{matrix} \right) =\left( \begin{matrix}
	\sum_{i=1,j=1}^3{a_{ij}}&		\sum_{i=1,j=1}^3{a_{ij}}&		\sum_{i=1,j=1}^3{a_{ij}}\\
	\sum_{i=1,j=1}^3{a_{ij}}&		\sum_{i=1,j=1}^3{a_{ij}}&		\sum_{i=1,j=1}^3{a_{ij}}\\
	\sum_{i=1,j=1}^3{a_{ij}}&		\sum_{i=1,j=1}^3{a_{ij}}&		\sum_{i=1,j=1}^3{a_{ij}}\\
\end{matrix} \right) $$
		在对结果矩阵乘以九分之一便得到了新的矩阵，不断遍历整个图像知道完全搞定，这就是均值滤波的原理
2. 它主要有两个输入的参数
	1. 第一个参数就是：需要处理的图像矩阵
	2. 第二个参数就是：所谓的单位矩阵的体积（长宽）
3. 例如：`blur = cv.blur(img,(3,3))`
### 16. **`cv.boxFilter()`**
1. 方框滤波和均值滤波的效果基本相同这里他的原理就不再进行说明了
2. 它主要有四个个输入参数
	1. 第一个参数：需要处理的图像
	2. 第二个参数：-1
	3. 第三个参数：所谓的单位矩阵的体积（长宽）
	4. 第四个参数：是否进行归一化处理（要不要乘以几分之几那个）
3. 例如:`box = cv.boxFilter(img,-1,(3,3),normalize=True)`
### 17. **`cv.GaussianBlur()`**
1. 高斯滤波，原理麻烦不说了，主要也是用来进行降噪的
2. 主要有三个参数：
	1. 第一个参数：需要处理的图像名
	2. 第二个参数就是：所谓的单位矩阵的体积（长宽）
	3. 第三个参数：可以说是迭代次数
3. 例如：`aussian = cv.GaussianBlur(img,(5,5),1)`
### 18. **`cv.medianBlur()`**
1. 中值滤波，远离也不说了，主要就是排序取种植
2. 主要有两个参数
	1. 第一个参数：需要处理的图像名
	2. 第二个参数：种植的矩阵长度
3. 例如：`median = cv.medianBlur(img,5)`
